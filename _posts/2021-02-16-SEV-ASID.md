---
layout: post
title:  "SEV ASID"
author: mengyuan
categories: [ Jekyll, tutorial ]
image: assets/images/asid.png
---
# Address Space ID (ASID)

Address Space ID (ASID) was initially designed by AMD to tag TLB entries so that unnecessary  TLB flushes can be avoided when switching between guest VMs and the host. SEV reuses ASID as the indices of VEKs stored in AMD-SP. Cache tags are also extended accordingly to isolate cache lines with different ASIDs. As a result, ASID becomes the de-facto identifier used by SEV processors to control the software's accesses to virtual memory, caches, and TLBs (shown below).

![asid_1]({{ site.baseurl }}/assets/images/asid_1.png)

However, following AMD-V, SEV allows the hypervisor to have (almost) complete authority over the management of ASIDs, which gives rise to security concerns as a malicious hypervisor may abuse this capability to breach ASID-based isolation.  
Interestingly, AMD adopts a "*security-by-crash*" principle and assumes if the wrong ASID is used for a guest, the execution of the instruction will likely cause a fault [1]. For more information related to the "*security-by-crash*" principle, please refer to the CROSSLINE [2]. In this blog, we set off to understand and demystify how ASIDs are used to isolate memory, cache, and TLBs in SEV, and how ASIDs are managed by the hypervisor.

## ASID-based Isolation

### ASID-based Memory Isolation

ASIDs are used by the AMD-SP to index VM encryption keys (VEKs) of SEV VMs. The SEV hardware ensures the data and code of an SEV VM is encrypted in the DRAM and only decrypted when loaded into the SOC. Specifically, each memory read from an SEV VM consists of memory fetches by the memory controller of a 128-bit aligned memory block, followed by an AES decryption by AMD-SP using the VEK corresponding to the current ASID. The current ASID is an integer stored in a hidden register of the current CPU core, which cannot be accessed by software in the guest VM.

SEV allows the guest OS to decide, by setting or clearing the C-bit of the PTE, whether each virtual memory page is (treated as) private (encrypted with the guest's VEK) or shared (either encrypted with the host's VEK or unencrypted). For instance, when the C-bit of a page is set, memory reads from this virtual-physical mapping is considered encrypted with the guest VM's VEK, regardless of its true encryption state, and thus a memory read in that page will be decrypted using the VEK of the current ASID. By default, the guest VM sets the guest C-bits for private pages during the boot period.

### ASID-based TLB Isolation

ASID was originally introduced to avoid TLB flushes when the execution context switches between the guest VM and the hypervisor, which is achieved by extending each TLB tag with ASID. With the ASID capability, when observing activities like MOV-to-CR3, context switches, updates of CR0.PG / CR4.PGE/CR4.PAE/CR4.PSE, the hardware does not need to flush the entire TLB, but only the TLB entries tagged with the current ASID[3]. However, to properly isolate TLB, the management of ASIDs for non-SEV VMs and SEV VMs is slightly different.

**Non-SEV VMs.**
Each VCPU of a non-SEV VM may have different ASIDs, which can be assigned dynamically before each VMRUN. More specifically, before the hypervisor is about to resume a VCPU with VMRUN, it checks if the VCPU was the one running on this CPU core before the control was trapped into the hypervisor. If so, the hypervisor keeps the ASID of the VCPU unchanged and resumes the VCPU directly; if not, the hypervisor selects another ASID (from the ASID pool) and assigns it to the VCPU. In the former case, TLB entries can be reused by the VCPU as its ASID is unchanged. However, in the latter case, the residual TLB entries (tagged with ASID of the hypervisor or the previous VCPU) should not be reused.

**SEV VMs.** 
SEV processors rely on a similar strategy to isolate entries in the TLBs with ASID. However, instead of dynamically assigning an ASID to a VCPU before VMRUN, all VCPUs of the same SEV VM are assigned the same ASID at launch time, which remains the same during the entire life cycle of the SEV VM.

### ASID-based Cache Isolation

On platforms that support SEV, cache lines are tagged with the VM's ASID indicating to which VM this data belongs, thus preventing the data from being misused by entities other than its owner[1]. When data is loaded into cache lines, according to the current ASID, AMD-SP automatically decrypts the data with the corresponding VEK and stores the ASID value into the cache tag. When a cache line is flushed or evicted, AMD-SP uses the ASID in the cache tag to determine which VEK to use when encrypting this cache line before writing it back to DRAM. The cache tag is also extended to include the C-bit[1]. Because the cache is now tagged with ASID and C-bit, cache coherence of the same physical address is not maintained if the two virtual memory pages do not have the same ASID and C-bit.  

## ASID Management

### ASID Life Cycle

The hypervisor reserves a pool (e.g., a range of integers) of available ASIDs for all VMs (we call all-ASID pool for simplicity), and a separate pool of ASIDs for SEV VMs (SEV-ASID pool). The maximum ID number of the all-ASID pool is determined by CPUID 0x8000000a[EBX] (e.g., 32768, thus the available ASIDs are whole numbers between 1 and 32767). The maximum ID number of the SEV-ASID pool is determined by CPUID 0x8000001f[ECX] (e.g., 15, which suggests the legal ASIDs for SEV VMs are 1 to 15). Note that ASID 0 is reserved for the host OS (i.e., hypervisor), and is also not allowed to be assigned to a VCPU for processors with or without SEV extensions [3].

On SEV platforms, the hypervisor uses *ACTIVATE* command to inform AMD-SP that a given guest is bound with an ASID and uses *DEACTIVATE* command to de-allocate an ASID from the guest. *DEACTIVATE* also uninstalls the guest VM's VEK. After a successful *DEACTIVATE*, if there is no available ASID in the SEV-ASID pool, the hypervisor may re-allocate the ASID to another VM [4].

At runtime, when the processor runs under the guest mode, the guest VM's ASID is stored in the ASID register that is hidden from software; when the processor runs under the host mode, the register is set to 0, which is the hypervisor's ASID. The guest VM's ASID is stored at the VMCB during VMEXIT. After VMRUN the processor restores the ASID in the VMCB. The VMCB State Cache allows the processor to cache some guest register values between VMEXIT and VMRUN for performance enhancement. The physical address of the VMCB is used to perform access control of the VMCB State Cache. However, the VMCB clean field controlled by the hypervisor can be used to force the processor to discard selected cached values. For example, bit-2 of the VMCB clean field indicates that an ASID reload is needed; bit-4 of the clean field indicates fields related to nest pages are dirty and needed to be reloaded from the VMCB. 

### ASID Restrictions

 SEV implements both launch-time and run-time restrictions about ASID.

**Launch-time restrictions.** 

On processors supporting SEV, the hypervisor cannot bind a current active ASID in the SEV-ASID pool to an SEV VM during launch time [4].
However, an adversary is able to deactivate the victim SEV VM and then activate an attacker SEV VM with the same ASID. The hardware requires the hypervisor to execute a *WBINVD* instruction and a *DF_FLUSH* instruction after deactivating an ASID and before re-activating it. The {\tt WBINVD} flushes all modified cache lines and invalidates all cache lines. The *DF_FLUSH* instruction flushes data fabric write buffers of all CPU cores. If these instructions are not executed before associating the ASID with a new VM, a *WBINVD_REQUIRED* or *DFFLUSH_REQUIRED* error will be returned by the AMD-SP and the VM launch process will be terminated.

This restriction is critical to the isolation of cache lines. Otherwise, the victim VM's residual cache data can be read by subsequent attacker VM. In particular, the attacker VM can use the *WBINVD* instruction to flush the cache data to memory. Cache lines belonging to the victim VM will thus be encrypted with the attacker VM's VEK and then flushed into the memory. Subsequent reads to those memory data will return plaintext and thus allow the adversary to extract the data.

**Run-time restrictions.**
After a VM is launched, the hypervisor can change its ASID during VMEXITs, by changing the ASID field of its VMCB, which will take effect when the VM is resumed. There is no additional hardware restriction at runtime. As such, it is possible to have two SEV VMs with the same ASID on the same machine, though the one with an incorrect ASID will crash very soon. %The hypervisor also needs to inform AMD-SP to deactive ASID once that SEV VM is destroyed.

Moreover, the VMCB also contains a field (090h) to indicate if the VM is an SEV VM or a non-SEV VM. Therefore, it is possible to first launch an SEV VM and a non-SEV VM with the same ASID, and then, during VMEXITs of the non-SEV VM, change the non-SEV VM into an SEV VM by setting the corresponding bit in the VMCB. It suggests that the hardware trusts the values of VMCB to determine (1) if the VM to be resumed is an SEV VM and (2) what ASID is associated with it. The hardware does not store this information to a secure memory region and use it for validation. The only additional validation performed by the AMD-SP is that the ASIDs of SEV VMs must fall into the valid ranges (The lower portion of the valid ASID range of SEV VMs are reserved for SEV-ES VMs. CPUID Fn8000_001F[ECX] specifies valid SEV ASIDs and CPUID Fn8000_001F[EDX] specifies the minimum ASID values used for SEV (but non-SEV-ES) VMs.).
Therefore, while a VM was launched as a non-SEV VM, we can effectively (though momentarily) make it an SEV VM with the same ASID as another SEV VM.

## Reference

[1] Kaplan, David, Jeremy Powell, and Tom Woller. "AMD memory encryption." White paper (2016).

[2] Li, Mengyuan, Yinqian Zhang, and Zhiqiang Lin. "CROSSLINE: Breaking''Security-by-Crash''based Memory Isolation in AMD SEV." ACM Conference on Computer and Communications Security (2021).

[3] AMD. "AMD64 architecture programmer’s manual volume 2: System programming." (2020).

[4] AMD. Secure Encrypted Virtualization API Specification." (2020).