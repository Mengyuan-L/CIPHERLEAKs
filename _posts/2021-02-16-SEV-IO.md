---
layout: post
title:  "SEV I/O"
author: mengyuan
categories: [ Jekyll, tutorial ]
image: assets/images/io.png
---
# IO

Similar to other virtualization technologies, SEV-enabled VMs interact with I/O devices through virtual hardware using Quick Emulator (QEMU). 
Common methods for VMs to perform I/O operations are programmed I/O, memory-mapped I/O, and direct memory access (DMA). Among these methods, DMA is the most frequently used method for SEV-enabled VMs to do I/O accesses.

### **Direct Memory Access in SEV**

With the assistance of A chips, programmable peripheral devices can transfer data to and from the main memory without involving the processor. With virtualization, a common way to support DMA is through IOMMU, which is a hardware memory management unit that maps the DMA-capable I/O buses to the main memory. However, unique to SEV is that the memory is encrypted. While the MMU supports memory encryption with multiple ASIDs, IOMMU only supports one ASID (e,g., ASID=0). Therefore, in SEV-enabled VMs, DMA operations are performed on memory pages that are shared between the guest and the hypervisor (encrypted with the hypervisor's memory encryption key). 

A bounce buffer, called Software I/O Translation Buffer (*SWIOTLB*), is allocated on these memory pages. The default *SWIOTLB* pool size in Linux Kernels is 64MB. When SEV is used, it is recommended to increase the size of *SWIOTLB* to 512MB to avoid *out-of-DMA-buffer* errors[1].

To illustrate the DMA operation from the guest, a disk I/O read is shown in the figure below. When a guest application needs to read data from the file, it first checks whether the file is already stored in its page cache. A miss in the guest page cache will trigger a read from virtual disks, which is emulated by QEMU-KVM. The data is actually read from the physical disk by QEMU-KVM's DMA operation into *SWIOTLB* and then copied to the disk device driver's I/O buffer by the guest VM itself. 
The disk write operation is the inverse of this process, in which the data is first copied from the guest into *SWIOTLB* and then processed by QEMU.

![io_1]({{ site.baseurl }}/assets/images/io_1.png)

### Reference:

[1] AMD. GitHub [How to setup AMD SEV](https://github.com/AMDESE/AMDSEV)